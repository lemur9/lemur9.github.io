<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/19/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/08/19/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="一、进程和线程"><a href="#一、进程和线程" class="headerlink" title="一、进程和线程"></a>一、进程和线程</h2><h3 id="1、进程"><a href="#1、进程" class="headerlink" title="1、进程"></a>1、进程</h3><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><h3 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h3><ul><li>一个进程之内可以分为一到多个线程。</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li><li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</li></ul><h3 id="3、二者对比"><a href="#3、二者对比" class="headerlink" title="3、二者对比"></a>3、二者对比</h3><ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li><li>进程拥有共享的资源，如内存空间等，供其内部的线程共享</li><li>进程间通信较为复杂<ul><li>同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h2 id="二、并行与并发"><a href="#二、并行与并发" class="headerlink" title="二、并行与并发"></a>二、并行与并发</h2><p>引用 Rob Pike 的一段描述：</p><ul><li>并发（concurrent）是同一时间应对（dealing with）多件事情的能力</li><li>并行（parallel）是同一时间动手做（doing）多件事情的能力</li></ul><p>例子</p><ul><li>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</li><li>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）</li><li>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</li></ul><h2 id="三、Java-线程"><a href="#三、Java-线程" class="headerlink" title="三、Java 线程"></a>三、Java 线程</h2><h3 id="1、创建和运行线程的几种方式"><a href="#1、创建和运行线程的几种方式" class="headerlink" title="1、创建和运行线程的几种方式"></a>1、创建和运行线程的几种方式</h3><h4 id="1-直接使用-Thread"><a href="#1-直接使用-Thread" class="headerlink" title="1) 直接使用 Thread"></a>1) 直接使用 Thread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 要执行的任务</span><br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></td></tr></table></figure><h4 id="2-使用-Runnable-配合-Thread"><a href="#2-使用-Runnable-配合-Thread" class="headerlink" title="2) 使用 Runnable 配合 Thread"></a>2) 使用 Runnable 配合 Thread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 要执行的任务</span><br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>( runnable );<br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></td></tr></table></figure><h4 id="3-FutureTask-配合-Thread"><a href="#3-FutureTask-配合-Thread" class="headerlink" title="3) FutureTask 配合 Thread"></a>3) FutureTask 配合 Thread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建任务对象</span><br>FutureTask&lt;Integer&gt; task3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>&#125;);<br><br><span class="hljs-comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task3, <span class="hljs-string">&quot;t3&quot;</span>).start();<br><br><span class="hljs-comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> task3.get();<br>log.debug(<span class="hljs-string">&quot;结果是:&#123;&#125;&quot;</span>, result);<br></code></pre></td></tr></table></figure><h3 id="2、查看进程线程的方法"><a href="#2、查看进程线程的方法" class="headerlink" title="2、查看进程线程的方法"></a>2、查看进程线程的方法</h3><h4 id="1-windows"><a href="#1-windows" class="headerlink" title="1) windows"></a>1) <strong>windows</strong></h4><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li><code>tasklist</code> 查看进程</li><li><code>taskkill</code> 杀死进程</li></ul><h4 id="2-linux"><a href="#2-linux" class="headerlink" title="2) linux"></a>2) <strong>linux</strong></h4><ul><li>ps -fe 查看所有进程</li><li><code>ps -fT -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li><li><code>kill</code> 杀死进程</li><li><code>top</code> 按大写 H 切换是否显示线程</li><li><code>top -H -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li></ul><h4 id="3-Java"><a href="#3-Java" class="headerlink" title="3) Java"></a>3) <strong>Java</strong></h4><ul><li><code>jps</code> 命令查看所有 Java 进程</li><li><code>jstack &lt;PID&gt;</code> 查看某个 Java 进程（PID）的所有线程状态</li><li><code>jconsole</code> 来查看某个 Java 进程中线程的运行情况（图形界面）</li></ul><p>jconsole 远程监控配置</p><ul><li>需要以如下方式运行你的 java 类</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -Djava.rmi.server.hostname=`ip地址` -Dcom.sun.management.jmxremote -<br>Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 -<br>Dcom.sun.management.jmxremote.authenticate=是否认证 java类<br></code></pre></td></tr></table></figure><ul><li>修改 &#x2F;etc&#x2F;hosts 文件将 127.0.0.1 映射至主机名</li></ul><p>如果要认证访问，还需要做如下步骤</p><ul><li>复制 jmxremote.password 文件</li><li>修改 jmxremote.password 和 jmxremote.access 文件的权限为 600 即文件所有者可读写</li><li>连接时填入 controlRole（用户名），R&amp;D（密码）</li></ul><h3 id="3、线程的几种状态"><a href="#3、线程的几种状态" class="headerlink" title="3、线程的几种状态"></a>3、线程的几种状态</h3><h4 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h4><p><img src="/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230819191824455.png" alt="image-20230819191824455"></p><ul><li><p>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</p></li><li><p>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</p></li><li><p>【运行状态】指获取了 CPU 时间片运行中的状态</p><ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li></ul></li><li><p>【阻塞状态】</p><ul><li><p>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】</p></li><li><p>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</p></li><li><p>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</p></li></ul></li><li><p>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p></li></ul><h4 id="六种状态"><a href="#六种状态" class="headerlink" title="六种状态"></a>六种状态</h4><p><img src="/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230819191647095.png" alt="image-20230819191647095"></p><ul><li><code>NEW</code> 线程刚被创建，但是还没有调用 start() 方法</li><li><code>RUNNABLE</code> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li><li><code>BLOCKED</code> ， <code>WAITING</code> ， <code>TIMED_WAITING</code> 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节详述</li><li><code>TERMINATED</code> 当线程代码运行结束</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>缓存问题思考逻辑</title>
    <link href="/2023/08/10/%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83%E9%80%BB%E8%BE%91/"/>
    <url>/2023/08/10/%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<h1 id="缓存问题思考逻辑"><a href="#缓存问题思考逻辑" class="headerlink" title="缓存问题思考逻辑"></a>缓存问题思考逻辑</h1><h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><p>涉及组件：Redis、Redisson、SpringCache</p><h2 id="一、缓存问题"><a href="#一、缓存问题" class="headerlink" title="一、缓存问题"></a>一、缓存问题</h2><ol><li>需要缓存<ul><li>解决方案：加本地缓存</li><li>存在问题：分布式系统无法使用</li></ul></li><li>使用缓存中间件<ul><li>解决方案：使用redis</li><li>存在问题：读模式下存在缓存穿透、雪崩、击穿问题</li></ul></li><li>解决读模式下的问题<ul><li>解决方案：<code>穿透</code>-&gt;缓存null值，<code>雪崩</code>-&gt;添加随机ttl，击穿-&gt;加本地锁</li><li>存在问题：分布式系统中本地锁无法完全锁住</li></ul></li><li>使用分布式锁<ul><li>解决方案：使用redisson</li><li>存在问题：降低效率</li></ul></li></ol><p>&#x3D;&#x3D;———————————————————————-&#x3D;&#x3D;</p><h2 id="二、缓存一致性问题"><a href="#二、缓存一致性问题" class="headerlink" title="二、缓存一致性问题"></a>二、缓存一致性问题</h2><ol><li>数据库和缓存数据需要保证一致<ul><li>解决方案：双写模式、失效模式+随机ttl</li><li>存在问题：可能出现脏读现象</li></ul></li><li>使用读写锁<ul><li>解决方案：使用RReadWriteLock，使用Canal感知数据库更新</li><li>存在问题：写锁阻塞读取操作</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>java组件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSS对象存储的使用</title>
    <link href="/2023/06/02/OSS%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/06/02/OSS%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="OSS对象存储"><a href="#OSS对象存储" class="headerlink" title="OSS对象存储"></a>OSS对象存储</h1><ul><li>适用于分布式系统</li></ul><h2 id="一、准备工作：开启阿里云的对象存储功能"><a href="#一、准备工作：开启阿里云的对象存储功能" class="headerlink" title="一、准备工作：开启阿里云的对象存储功能"></a>一、准备工作：开启阿里云的对象存储功能</h2><h3 id="1-创建阿里云账号，开启-对象存储OSS-功能"><a href="#1-创建阿里云账号，开启-对象存储OSS-功能" class="headerlink" title="1. 创建阿里云账号，开启 对象存储OSS 功能"></a>1. 创建阿里云账号，开启 <em>对象存储OSS</em> 功能</h3><p><img src="/2023/06/02/OSS%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%BF%E7%94%A8/img_2.png" alt="开启对象存储OSS功能"></p><h3 id="2-创建一个Bucket，读写权限选择-公共读-即可"><a href="#2-创建一个Bucket，读写权限选择-公共读-即可" class="headerlink" title="2. 创建一个Bucket，读写权限选择 公共读 即可"></a>2. 创建一个Bucket，读写权限选择 <em>公共读</em> 即可</h3><p><img src="/2023/06/02/OSS%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%BF%E7%94%A8/img_1.png" alt="创建Bucket"></p><h3 id="3-进入创建好的Bucket，可以选择上传文件进行测试"><a href="#3-进入创建好的Bucket，可以选择上传文件进行测试" class="headerlink" title="3. 进入创建好的Bucket，可以选择上传文件进行测试"></a>3. 进入创建好的Bucket，可以选择上传文件进行测试</h3><p><img src="/2023/06/02/OSS%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%BF%E7%94%A8/img.png" alt="测试上传文件"><br>访问详情中的url即可在线预览</p><h3 id="4-创建子用户，获取AccessKey"><a href="#4-创建子用户，获取AccessKey" class="headerlink" title="4. 创建子用户，获取AccessKey"></a>4. 创建子用户，获取AccessKey</h3><p><img src="/2023/06/02/OSS%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%BF%E7%94%A8/img_4.png" alt="img_4.png"><br><img src="/2023/06/02/OSS%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%BF%E7%94%A8/img_5.png" alt="img_5.png"><br><img src="/2023/06/02/OSS%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%BF%E7%94%A8/img_6.png" alt="img_6.png"><br>记录下AccessKey ID 和 AccessKey Secret</p><h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h3><p>注：这里选错了使用的Gradle，熟悉Maven可以自行使用Maven构建。<br><img src="/2023/06/02/OSS%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%BF%E7%94%A8/img_3.png" alt="创建一个SpringBoot项目"></p><h3 id="2-编写资源文件"><a href="#2-编写资源文件" class="headerlink" title="2. 编写资源文件"></a>2. 编写资源文件</h3><p>accessKey对应AccessKey ID <br>secretKey对应AccessKey Secret <br>endpoint对应Bucket概览页中的访问端口的地域节点<br>bucket为对应的bucket<br><img src="/2023/06/02/OSS%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%BF%E7%94%A8/img_7.png" alt="资源文件"></p><h3 id="3-简单上传代码实现"><a href="#3-简单上传代码实现" class="headerlink" title="3. 简单上传代码实现"></a>3. 简单上传代码实现</h3><h4 id="OssController"><a href="#OssController" class="headerlink" title="OssController"></a>OssController</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@ConfigurationProperties(&quot;alibaba.cloud&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OssController</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String accessKey;<br><br>    <span class="hljs-keyword">private</span> String secretKey;<br><br>    <span class="hljs-keyword">private</span> Oss oss;<br><br>    <span class="hljs-meta">@Data</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Oss</span> &#123;<br>        <span class="hljs-keyword">private</span> String endpoint;<br><br>        <span class="hljs-keyword">private</span> String bucket;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Resource</span><br>    OSS ossClient;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;oss/test&quot;)</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testOss</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-comment">// 填写Object完整路径，完整路径中不能包含Bucket名称，例如exampledir/exampleobject.txt。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">objectName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;IMG_2184(20200719-184751).JPG&quot;</span>;<br><br>        String filePath= <span class="hljs-string">&quot;IMG_2184(20200719-184751).JPG&quot;</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> ClassLoader.getSystemResourceAsStream(filePath);<br>            <span class="hljs-comment">// 创建PutObjectRequest对象。</span><br>            <span class="hljs-type">PutObjectRequest</span> <span class="hljs-variable">putObjectRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PutObjectRequest</span>(oss.bucket, objectName, inputStream);<br>            <span class="hljs-comment">// 创建PutObject请求。</span><br>            ossClient.putObject(putObjectRequest);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@ConfigurationPropertiesScan</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OssFileUploadApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(OssFileUploadApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="浏览器访问"><a href="#浏览器访问" class="headerlink" title="浏览器访问"></a>浏览器访问</h4><p><a href="http://localhost:30000/oss/test">http://localhost:30000/oss/test</a> \</p><h3 id="4-查看"><a href="#4-查看" class="headerlink" title="4. 查看"></a>4. 查看</h3><h4 id="点击对应图片的详情按钮，对应URL也可直接访问"><a href="#点击对应图片的详情按钮，对应URL也可直接访问" class="headerlink" title="点击对应图片的详情按钮，对应URL也可直接访问"></a>点击对应图片的详情按钮，对应URL也可直接访问</h4><p><img src="/2023/06/02/OSS%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%BF%E7%94%A8/img_10.png" alt="img_10.png"></p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>文件目录 <br><img src="/2023/06/02/OSS%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%BF%E7%94%A8/img_9.png" alt="文件目录"> <br>贴上测试图片 <br><img src="/2023/06/02/OSS%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%BF%E7%94%A8/img_8.png" alt="测试图片"></p><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>此处只做简单测试，具体使用详情可见阿里云官方文档：<a href="https://help.aliyun.com/document_detail/84781.html">https://help.aliyun.com/document_detail/84781.html</a></p>]]></content>
    
    
    <categories>
      
      <category>java组件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OSS对象存储</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小记</title>
    <link href="/2023/06/01/%E5%B0%8F%E8%AE%B0/"/>
    <url>/2023/06/01/%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h1><p>记录图片上传方式</p><img src="/2023/06/01/%E5%B0%8F%E8%AE%B0/IMG_2184(20200719-184751).JPG" class="" title="图片引用方法一"><p><img src="/2023/06/01/%E5%B0%8F%E8%AE%B0/IMG_2184(20200719-184751).JPG"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
